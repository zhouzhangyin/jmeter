<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.8" jmeter="2.13 r1665067">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="测试计划" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="服务器相关变量" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="http_address" elementType="Argument">
            <stringProp name="Argument.name">http_address</stringProp>
            <stringProp name="Argument.value">112.74.115.143</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">http接口地址</stringProp>
          </elementProp>
          <elementProp name="http_port" elementType="Argument">
            <stringProp name="Argument.name">http_port</stringProp>
            <stringProp name="Argument.value">8889</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">http端口</stringProp>
          </elementProp>
          <elementProp name="http_address_test" elementType="Argument">
            <stringProp name="Argument.name">http_address_test</stringProp>
            <stringProp name="Argument.value">192.168.1.144</stringProp>
            <stringProp name="Argument.desc">测试地址</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="http_port_test" elementType="Argument">
            <stringProp name="Argument.name">http_port_test</stringProp>
            <stringProp name="Argument.value">8080</stringProp>
            <stringProp name="Argument.desc">http测试端口</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="domain" elementType="Argument">
            <stringProp name="Argument.name">domain</stringProp>
            <stringProp name="Argument.value">cms.bjjajale.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">java接口域名</stringProp>
          </elementProp>
          <elementProp name="socket_address" elementType="Argument">
            <stringProp name="Argument.name">socket_address</stringProp>
            <stringProp name="Argument.value">112.74.115.143</stringProp>
            <stringProp name="Argument.desc">socket服务器地址</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="socket_port" elementType="Argument">
            <stringProp name="Argument.name">socket_port</stringProp>
            <stringProp name="Argument.value">20002</stringProp>
            <stringProp name="Argument.desc">app端socket请求接口</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="sql_address" elementType="Argument">
            <stringProp name="Argument.name">sql_address</stringProp>
            <stringProp name="Argument.value">120.76.42.1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">数据库地址</stringProp>
          </elementProp>
          <elementProp name="sql_port" elementType="Argument">
            <stringProp name="Argument.name">sql_port</stringProp>
            <stringProp name="Argument.value">1433</stringProp>
            <stringProp name="Argument.desc">sql数据库端口</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="path" elementType="Argument">
            <stringProp name="Argument.name">path</stringProp>
            <stringProp name="Argument.value">/User/Entrance</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">请求路径</stringProp>
          </elementProp>
          <elementProp name="timeout" elementType="Argument">
            <stringProp name="Argument.name">timeout</stringProp>
            <stringProp name="Argument.value">5000</stringProp>
            <stringProp name="Argument.desc">请求及响应超时时间（ms）</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="databaseName" elementType="Argument">
            <stringProp name="Argument.name">databaseName</stringProp>
            <stringProp name="Argument.value">JaJaLeDB</stringProp>
            <stringProp name="Argument.desc">sqlserver数据库库名</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="请求一般参数变量" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="app_v" elementType="Argument">
            <stringProp name="Argument.name">app_v</stringProp>
            <stringProp name="Argument.value">1.1.9</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">app版本</stringProp>
          </elementProp>
          <elementProp name="platform" elementType="Argument">
            <stringProp name="Argument.name">platform</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.desc">app类型（Android：1，iOS：2）</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiversion" elementType="Argument">
            <stringProp name="Argument.name">apiversion</stringProp>
            <stringProp name="Argument.value">1.0</stringProp>
            <stringProp name="Argument.desc">接口版本</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="data" elementType="Argument">
            <stringProp name="Argument.name">data</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">http请求data内容</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="num" elementType="Argument">
            <stringProp name="Argument.name">num</stringProp>
            <stringProp name="Argument.value">jajale</stringProp>
            <stringProp name="Argument.desc">万能验证码</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="pageIndex" elementType="Argument">
            <stringProp name="Argument.name">pageIndex</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.desc">列表页数</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="pageSize" elementType="Argument">
            <stringProp name="Argument.name">pageSize</stringProp>
            <stringProp name="Argument.value">20</stringProp>
            <stringProp name="Argument.desc">每页显示数量</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="smskey" elementType="Argument">
            <stringProp name="Argument.name">smskey</stringProp>
            <stringProp name="Argument.value">96e79218965eb72c92a549dd5a330112</stringProp>
            <stringProp name="Argument.desc">发送验证码key</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="用户相关变量" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="mobile" elementType="Argument">
            <stringProp name="Argument.name">mobile</stringProp>
            <stringProp name="Argument.value">18801228228</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">手机号</stringProp>
          </elementProp>
          <elementProp name="nick_name" elementType="Argument">
            <stringProp name="Argument.name">nick_name</stringProp>
            <stringProp name="Argument.value">玉玺</stringProp>
            <stringProp name="Argument.desc">用户昵称</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="password" elementType="Argument">
            <stringProp name="Argument.name">password</stringProp>
            <stringProp name="Argument.value">111111</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">密码</stringProp>
          </elementProp>
          <elementProp name="newPassword" elementType="Argument">
            <stringProp name="Argument.name">newPassword</stringProp>
            <stringProp name="Argument.value">888888</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">重置的新密码</stringProp>
          </elementProp>
          <elementProp name="portrait" elementType="Argument">
            <stringProp name="Argument.name">portrait</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">宝贝头像地址</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="msgid" elementType="Argument">
            <stringProp name="Argument.name">msgid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">消息id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="userid" elementType="Argument">
            <stringProp name="Argument.name">userid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">用户id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="adviceid" elementType="Argument">
            <stringProp name="Argument.name">adviceid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">广告id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="宝贝相关变量" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="imei" elementType="Argument">
            <stringProp name="Argument.name">imei</stringProp>
            <stringProp name="Argument.value">868056020011303</stringProp>
            <stringProp name="Argument.desc">手表串号</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="nickname" elementType="Argument">
            <stringProp name="Argument.name">nickname</stringProp>
            <stringProp name="Argument.value">小布点</stringProp>
            <stringProp name="Argument.desc">宝贝昵称</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="babyphone" elementType="Argument">
            <stringProp name="Argument.name">babyphone</stringProp>
            <stringProp name="Argument.value">13260183138</stringProp>
            <stringProp name="Argument.desc">宝贝电话</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="babybirthday" elementType="Argument">
            <stringProp name="Argument.name">babybirthday</stringProp>
            <stringProp name="Argument.value">2014-12-19</stringProp>
            <stringProp name="Argument.desc">宝贝生日</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="babygender" elementType="Argument">
            <stringProp name="Argument.name">babygender</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.desc">宝贝性别</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="gpsmodel" elementType="Argument">
            <stringProp name="Argument.name">gpsmodel</stringProp>
            <stringProp name="Argument.value">3</stringProp>
            <stringProp name="Argument.desc">手表定位模式</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="clock" elementType="Argument">
            <stringProp name="Argument.name">clock</stringProp>
            <stringProp name="Argument.value">&quot;time&quot;:&quot;07:30&quot;,&quot;number&quot;:&quot;1&quot;,&quot;onOFF&quot;:&quot;1&quot;,&quot;type&quot;:&quot;2&quot;,&quot;setValues&quot;:&quot;1111111&quot;</stringProp>
            <stringProp name="Argument.desc">闹钟</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="relation" elementType="Argument">
            <stringProp name="Argument.name">relation</stringProp>
            <stringProp name="Argument.value">爷爷</stringProp>
            <stringProp name="Argument.desc">与宝贝关系</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="growth" elementType="Argument">
            <stringProp name="Argument.name">growth</stringProp>
            <stringProp name="Argument.value">&quot;height&quot;:${__Random(20,175,)},&quot;weight&quot;:${__Random(0,70,)},&quot;create_time&quot;:&quot;${__time(YYYY-MM-DD HH:MM:ss,)}&quot;,&quot;content&quot;:&quot;&quot;</stringProp>
            <stringProp name="Argument.desc">生长记录</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="headerimgurl" elementType="Argument">
            <stringProp name="Argument.name">headerimgurl</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">头像地址</stringProp>
          </elementProp>
          <elementProp name="safeArea" elementType="Argument">
            <stringProp name="Argument.name">safeArea</stringProp>
            <stringProp name="Argument.value">&quot;safe_title&quot;: &quot;家&quot;,&quot;gps_lat&quot;:&quot;22.552233759259&quot;,&quot;gps_lon&quot;:&quot;114.01834289802&quot;,&quot;radius&quot;:&quot;500&quot;,&quot;address&quot;:&quot;新纪元大厦&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">安全区域</stringProp>
          </elementProp>
          <elementProp name="disturb" elementType="Argument">
            <stringProp name="Argument.name">disturb</stringProp>
            <stringProp name="Argument.value">&quot;beginTime&quot;:&quot;10:30&quot;,&quot;endTime&quot;:&quot;11:30&quot;,&quot;number&quot;:&quot;1&quot;,&quot;onOFF&quot;:&quot;1&quot;</stringProp>
            <stringProp name="Argument.desc">免打扰</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="sos" elementType="Argument">
            <stringProp name="Argument.name">sos</stringProp>
            <stringProp name="Argument.value">&quot;sosList&quot;:[{&quot;phone&quot;:&quot;18801228228&quot;,&quot;number&quot;:&quot;1&quot;},{&quot;phone&quot;:&quot;2&quot;,&quot;number&quot;:&quot;18801228228&quot;}]</stringProp>
            <stringProp name="Argument.desc">sos列表</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="phonebook" elementType="Argument">
            <stringProp name="Argument.name">phonebook</stringProp>
            <stringProp name="Argument.value">&quot;phoneList&quot;:[{&quot;phone&quot;:&quot;18801228228&quot;,&quot;nickName&quot;:&quot;爷爷&quot;,&quot;number&quot;:&quot;1&quot;},{&quot;phone&quot;:&quot;18801228229&quot;,&quot;nickName&quot;:&quot;奶奶&quot;,&quot;number&quot;:&quot;2&quot;}]</stringProp>
            <stringProp name="Argument.desc">电话薄</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="watchid" elementType="Argument">
            <stringProp name="Argument.name">watchid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">手表id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="growthid" elementType="Argument">
            <stringProp name="Argument.name">growthid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">成长记录id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="safeid" elementType="Argument">
            <stringProp name="Argument.name">safeid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">安全区域id</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="java接口测试" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1452136892000</longProp>
        <longProp name="ThreadGroup.end_time">1452136892000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="请求路径" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="isRegister" elementType="Argument">
              <stringProp name="Argument.name">isRegister</stringProp>
              <stringProp name="Argument.value">/apiUserControl/isRegister.do</stringProp>
              <stringProp name="Argument.desc">是否注册</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="register" elementType="Argument">
              <stringProp name="Argument.name">register</stringProp>
              <stringProp name="Argument.value">/apiUserControl/register.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">注册地址</stringProp>
            </elementProp>
            <elementProp name="login" elementType="Argument">
              <stringProp name="Argument.name">login</stringProp>
              <stringProp name="Argument.value">/apiUserControl/login.do</stringProp>
              <stringProp name="Argument.desc">登录</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="resetPw" elementType="Argument">
              <stringProp name="Argument.name">resetPw</stringProp>
              <stringProp name="Argument.value">/apiUserControl/resetPassword.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">重置密码</stringProp>
            </elementProp>
            <elementProp name="getWatchList" elementType="Argument">
              <stringProp name="Argument.name">getWatchList</stringProp>
              <stringProp name="Argument.value">/apiUserControl/getWatchList.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取用户绑定手表列表</stringProp>
            </elementProp>
            <elementProp name="bindWatch" elementType="Argument">
              <stringProp name="Argument.name">bindWatch</stringProp>
              <stringProp name="Argument.value">/apiUserControl/bindWatch.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">绑定手表</stringProp>
            </elementProp>
            <elementProp name="editRelation" elementType="Argument">
              <stringProp name="Argument.name">editRelation</stringProp>
              <stringProp name="Argument.value">/apiUserRelationControl/insert.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置关系</stringProp>
            </elementProp>
            <elementProp name="editUserInfo" elementType="Argument">
              <stringProp name="Argument.name">editUserInfo</stringProp>
              <stringProp name="Argument.value">/apiUserControl/update.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑用户信息</stringProp>
            </elementProp>
            <elementProp name="editBabyInfo" elementType="Argument">
              <stringProp name="Argument.name">editBabyInfo</stringProp>
              <stringProp name="Argument.value">/apiUserControl/update.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑宝贝信息</stringProp>
            </elementProp>
            <elementProp name="getWatchFamliyList" elementType="Argument">
              <stringProp name="Argument.name">getWatchFamliyList</stringProp>
              <stringProp name="Argument.value">/apiUserControl/getWatchList.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取宝贝的家庭成员</stringProp>
            </elementProp>
            <elementProp name="unbindWatch" elementType="Argument">
              <stringProp name="Argument.name">unbindWatch</stringProp>
              <stringProp name="Argument.value">/apiUserRelationControl/deleteRelation.do</stringProp>
              <stringProp name="Argument.desc">用户解绑手表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getPhoneBook" elementType="Argument">
              <stringProp name="Argument.name">getPhoneBook</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/getWatchPhoneBookList.do</stringProp>
              <stringProp name="Argument.desc">获取手表电话簿</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getSosList" elementType="Argument">
              <stringProp name="Argument.name">getSosList</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/getWatchSOSList.do</stringProp>
              <stringProp name="Argument.desc">获取sos列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getWatchDisturbList" elementType="Argument">
              <stringProp name="Argument.name">getWatchDisturbList</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/getWatchDisturbList.do</stringProp>
              <stringProp name="Argument.desc">获取手表免打扰列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getWatchClockList" elementType="Argument">
              <stringProp name="Argument.name">getWatchClockList</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/getWatchClockList.do</stringProp>
              <stringProp name="Argument.desc">获取手表闹钟列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getWatchSafeAreaList" elementType="Argument">
              <stringProp name="Argument.name">getWatchSafeAreaList</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/getWatchSafeAreaList.do</stringProp>
              <stringProp name="Argument.desc">获取安全围栏列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="addBabyGrowth" elementType="Argument">
              <stringProp name="Argument.name">addBabyGrowth</stringProp>
              <stringProp name="Argument.value">/apiBabyGrowthControl/addApiBabyGrowthInfo.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">增加宝贝成长记录</stringProp>
            </elementProp>
            <elementProp name="editBabyGrowth" elementType="Argument">
              <stringProp name="Argument.name">editBabyGrowth</stringProp>
              <stringProp name="Argument.value">/apiBabyGrowthControl/editApiBabyGrowthInfo.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑宝贝成长记录</stringProp>
            </elementProp>
            <elementProp name="getBabyGrowth" elementType="Argument">
              <stringProp name="Argument.name">getBabyGrowth</stringProp>
              <stringProp name="Argument.value">/apiBabyGrowthControl/getApiBabyGrowthListByParams.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取宝贝成长记录</stringProp>
            </elementProp>
            <elementProp name="delBabyGrowth" elementType="Argument">
              <stringProp name="Argument.name">delBabyGrowth</stringProp>
              <stringProp name="Argument.value">/apiBabyGrowthControl/delApiBabyGrowthInfo.do</stringProp>
              <stringProp name="Argument.desc">删除宝贝成长记录</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="versionUpdate" elementType="Argument">
              <stringProp name="Argument.name">versionUpdate</stringProp>
              <stringProp name="Argument.value">/apiAppVersionControl/appUpdate.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">版本升级</stringProp>
            </elementProp>
            <elementProp name="addSafeArea" elementType="Argument">
              <stringProp name="Argument.name">addSafeArea</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/addWatchSafeArea.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">增加安全区域</stringProp>
            </elementProp>
            <elementProp name="editSafeArea" elementType="Argument">
              <stringProp name="Argument.name">editSafeArea</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/upWatchSafeArea.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑安全区域</stringProp>
            </elementProp>
            <elementProp name="delSafeArea" elementType="Argument">
              <stringProp name="Argument.name">delSafeArea</stringProp>
              <stringProp name="Argument.value">/apiWatchConfigControl/delWatchSafeArea.do</stringProp>
              <stringProp name="Argument.desc">删除安全区域</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getTrajectoryList" elementType="Argument">
              <stringProp name="Argument.name">getTrajectoryList</stringProp>
              <stringProp name="Argument.value">/apiWatchReportDataControl/trajectoryList.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取历史轨迹</stringProp>
            </elementProp>
            <elementProp name="addFeedBack" elementType="Argument">
              <stringProp name="Argument.name">addFeedBack</stringProp>
              <stringProp name="Argument.value">/apiFeedBackControl/addUserApiFeedBack.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">意见反馈</stringProp>
            </elementProp>
            <elementProp name="getAgesList" elementType="Argument">
              <stringProp name="Argument.name">getAgesList</stringProp>
              <stringProp name="Argument.value">/apiVaccineControl/getAgesList.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取年龄列表</stringProp>
            </elementProp>
            <elementProp name="getAgeVaccines" elementType="Argument">
              <stringProp name="Argument.name">getAgeVaccines</stringProp>
              <stringProp name="Argument.value">/apiVaccineBabyControl/getApiVaccinesByUserIdAndVaccineId.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取某个年龄下疫苗接种情况</stringProp>
            </elementProp>
            <elementProp name="moveManager" elementType="Argument">
              <stringProp name="Argument.name">moveManager</stringProp>
              <stringProp name="Argument.value">/apiUserRelationControl/moveManage.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">移交管理员权限</stringProp>
            </elementProp>
            <elementProp name="getAdv" elementType="Argument">
              <stringProp name="Argument.name">getAdv</stringProp>
              <stringProp name="Argument.value">/apiAppAdControl/show.do</stringProp>
              <stringProp name="Argument.desc">获取启动图</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getInfoImg" elementType="Argument">
              <stringProp name="Argument.name">getInfoImg</stringProp>
              <stringProp name="Argument.value">/apiAppAdControl/informationImg.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取咨询广告图</stringProp>
            </elementProp>
            <elementProp name="getIsCerti" elementType="Argument">
              <stringProp name="Argument.name">getIsCerti</stringProp>
              <stringProp name="Argument.value">/apiWatchCertificationControl/isCertification.do</stringProp>
              <stringProp name="Argument.desc">是否需要实名认证</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="uploadCertification" elementType="Argument">
              <stringProp name="Argument.name">uploadCertification</stringProp>
              <stringProp name="Argument.value">/apiWatchCertificationControl/uploadCertificationData.do</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">上传实名认证</stringProp>
            </elementProp>
            <elementProp name="getInformationList" elementType="Argument">
              <stringProp name="Argument.name">getInformationList</stringProp>
              <stringProp name="Argument.value">/apiInformationControl/getInformationList.do</stringProp>
              <stringProp name="Argument.desc">获取咨询列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getInfoDetail" elementType="Argument">
              <stringProp name="Argument.name">getInfoDetail</stringProp>
              <stringProp name="Argument.value">/apiInformationControl/getInformationdetail.do</stringProp>
              <stringProp name="Argument.desc">获取咨询内容</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="sendSMS" elementType="Argument">
              <stringProp name="Argument.name">sendSMS</stringProp>
              <stringProp name="Argument.value">/apiCmsValidateControl/validateKey.do</stringProp>
              <stringProp name="Argument.desc">发送验证码</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="findWatch" elementType="Argument">
              <stringProp name="Argument.name">findWatch</stringProp>
              <stringProp name="Argument.value">/watchConfig/findWatch.do</stringProp>
              <stringProp name="Argument.desc">找手表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="sendMsg" elementType="Argument">
              <stringProp name="Argument.name">sendMsg</stringProp>
              <stringProp name="Argument.value">/msgController/sendMsg.do</stringProp>
              <stringProp name="Argument.desc">app发送消息</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getMsg" elementType="Argument">
              <stringProp name="Argument.name">getMsg</stringProp>
              <stringProp name="Argument.value">/msgController/getMsgList.do</stringProp>
              <stringProp name="Argument.desc">拉取消息</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setClock" elementType="Argument">
              <stringProp name="Argument.name">setClock</stringProp>
              <stringProp name="Argument.value">/watchConfig/setApiWatchClock.do</stringProp>
              <stringProp name="Argument.desc">设置闹钟</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setDisturb" elementType="Argument">
              <stringProp name="Argument.name">setDisturb</stringProp>
              <stringProp name="Argument.value">/watchConfig/disturb.do</stringProp>
              <stringProp name="Argument.desc">设置免打扰</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setSos" elementType="Argument">
              <stringProp name="Argument.name">setSos</stringProp>
              <stringProp name="Argument.value">/watchConfig/sos_phone_set.do</stringProp>
              <stringProp name="Argument.desc">设置sos</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setPhoneBook" elementType="Argument">
              <stringProp name="Argument.name">setPhoneBook</stringProp>
              <stringProp name="Argument.value">/watchConfig/phone_book.do</stringProp>
              <stringProp name="Argument.desc">设置电话薄</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setStep" elementType="Argument">
              <stringProp name="Argument.name">setStep</stringProp>
              <stringProp name="Argument.value">/watchConfig/switch_step.do</stringProp>
              <stringProp name="Argument.desc">记步开关</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="setGPSMode" elementType="Argument">
              <stringProp name="Argument.name">setGPSMode</stringProp>
              <stringProp name="Argument.value">/watchConfig/gpsMode.do</stringProp>
              <stringProp name="Argument.desc">定位模式</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="powerOff" elementType="Argument">
              <stringProp name="Argument.name">powerOff</stringProp>
              <stringProp name="Argument.value">/watchConfig/power_off.do</stringProp>
              <stringProp name="Argument.desc">远程关机</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="请求的data参数" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="dataCheckMobile" elementType="Argument">
              <stringProp name="Argument.name">dataCheckMobile</stringProp>
              <stringProp name="Argument.value">{&quot;user_name&quot;:&quot;${mobile}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">检查手机号是否注册</stringProp>
            </elementProp>
            <elementProp name="dataRegister" elementType="Argument">
              <stringProp name="Argument.name">dataRegister</stringProp>
              <stringProp name="Argument.value">{&quot;user_name&quot;:&quot;${mobile}&quot;,&quot;password&quot;:&quot;${__MD5(${password},)}&quot;,&quot;num&quot;:&quot;${num}&quot;,&quot;channel&quot;:&quot;2000&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">注册</stringProp>
            </elementProp>
            <elementProp name="dataLogin" elementType="Argument">
              <stringProp name="Argument.name">dataLogin</stringProp>
              <stringProp name="Argument.value">{&quot;user_name&quot;:&quot;${mobile}&quot;,&quot;password&quot;:&quot;${__MD5(${password},)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">登录</stringProp>
            </elementProp>
            <elementProp name="dataBindWatch" elementType="Argument">
              <stringProp name="Argument.name">dataBindWatch</stringProp>
              <stringProp name="Argument.value">{&quot;imei&quot;:&quot;${imei}&quot;,&quot;user_id&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">绑定手表</stringProp>
            </elementProp>
            <elementProp name="dataSetRelation" elementType="Argument">
              <stringProp name="Argument.name">dataSetRelation</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;${watchid}&quot;,&quot;relation&quot;:&quot;${relation}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置关系</stringProp>
            </elementProp>
            <elementProp name="dataGetUserWatches" elementType="Argument">
              <stringProp name="Argument.name">dataGetUserWatches</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取用户绑定的所有手表</stringProp>
            </elementProp>
            <elementProp name="dataResetPassword" elementType="Argument">
              <stringProp name="Argument.name">dataResetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;user_name&quot;:&quot;${mobile}&quot;,&quot;password&quot;:&quot;${__MD5(${newPassword},)}&quot;,&quot;num&quot;:&quot;${num}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置密码</stringProp>
            </elementProp>
            <elementProp name="dataSecondResetPassword" elementType="Argument">
              <stringProp name="Argument.name">dataSecondResetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;user_name&quot;:&quot;${mobile}&quot;,&quot;password&quot;:&quot;${__MD5(${password},)}&quot;,&quot;num&quot;:&quot;${num}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">重新设置密码</stringProp>
            </elementProp>
            <elementProp name="dataEditUserinfo" elementType="Argument">
              <stringProp name="Argument.name">dataEditUserinfo</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;nick_name&quot;:&quot;${nick_name}&quot;,&quot;header_img_url&quot;:&quot;${portrait}&quot;}</stringProp>
              <stringProp name="Argument.desc">编辑用户信息</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataEditBabyInfo" elementType="Argument">
              <stringProp name="Argument.name">dataEditBabyInfo</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;sex&quot;:&quot;${babygender}&quot;,&quot;nick_name&quot;:&quot;${nickname}&quot;,&quot;phone_num_binded&quot;:&quot;${babyphone}&quot;,&quot;header_img_url&quot;:&quot;${headerimgurl}&quot;,&quot;birthday&quot;:&quot;${babybirthday}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑宝贝信息</stringProp>
            </elementProp>
            <elementProp name="dataGetFamliyList" elementType="Argument">
              <stringProp name="Argument.name">dataGetFamliyList</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取家庭成员列表</stringProp>
            </elementProp>
            <elementProp name="dataUnbindWatch" elementType="Argument">
              <stringProp name="Argument.name">dataUnbindWatch</stringProp>
              <stringProp name="Argument.value">{&quot;friend_id&quot;:&quot;43&quot;,&quot;user_id&quot;:&quot;UID&quot;,&quot;unbind_id&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">解绑手表</stringProp>
            </elementProp>
            <elementProp name="dataGetPhoneBook" elementType="Argument">
              <stringProp name="Argument.name">dataGetPhoneBook</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.desc">获取电话薄</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataGetSos" elementType="Argument">
              <stringProp name="Argument.name">dataGetSos</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.desc">获取sos列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataGetDisturb" elementType="Argument">
              <stringProp name="Argument.name">dataGetDisturb</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取免打扰列表</stringProp>
            </elementProp>
            <elementProp name="dataGetClock" elementType="Argument">
              <stringProp name="Argument.name">dataGetClock</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.desc">获取闹钟列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataGetSafeArea" elementType="Argument">
              <stringProp name="Argument.name">dataGetSafeArea</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.desc">获取安全围栏</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataAddGrowth" elementType="Argument">
              <stringProp name="Argument.name">dataAddGrowth</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,${growth}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">添加成长记录</stringProp>
            </elementProp>
            <elementProp name="dataGetGrowth" elementType="Argument">
              <stringProp name="Argument.name">dataGetGrowth</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;pageIndex&quot;:&quot;${pageIndex}&quot;,&quot;pageSize&quot;:&quot;${pageSize}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取成长记录</stringProp>
            </elementProp>
            <elementProp name="dataEditGrowth" elementType="Argument">
              <stringProp name="Argument.name">dataEditGrowth</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;growth_id&quot;:&quot;GID&quot;,${growth}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑成长记录</stringProp>
            </elementProp>
            <elementProp name="dataDelGrowth" elementType="Argument">
              <stringProp name="Argument.name">dataDelGrowth</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;growth_id&quot;:&quot;GID&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">删除成长记录</stringProp>
            </elementProp>
            <elementProp name="dataVersionUpdate" elementType="Argument">
              <stringProp name="Argument.name">dataVersionUpdate</stringProp>
              <stringProp name="Argument.value">{}</stringProp>
              <stringProp name="Argument.desc">版本升级</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataAddSafeArea" elementType="Argument">
              <stringProp name="Argument.name">dataAddSafeArea</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,${safeArea}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">增加安全区域</stringProp>
            </elementProp>
            <elementProp name="dataEditSafeArea" elementType="Argument">
              <stringProp name="Argument.name">dataEditSafeArea</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;safe_id&quot;:&quot;SFID&quot;,${safeArea}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">编辑安全区域</stringProp>
            </elementProp>
            <elementProp name="dataDelSafeArea" elementType="Argument">
              <stringProp name="Argument.name">dataDelSafeArea</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;safe_id&quot;:&quot;SFID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">删除安全区域</stringProp>
            </elementProp>
            <elementProp name="dataFeedBack" elementType="Argument">
              <stringProp name="Argument.name">dataFeedBack</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;content&quot;:&quot;haah&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">意见反馈</stringProp>
            </elementProp>
            <elementProp name="dataGetAgesList" elementType="Argument">
              <stringProp name="Argument.name">dataGetAgesList</stringProp>
              <stringProp name="Argument.value">{}</stringProp>
              <stringProp name="Argument.desc">获取疫苗年龄列表</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataGetAgeVaccine" elementType="Argument">
              <stringProp name="Argument.name">dataGetAgeVaccine</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;age&quot;:&quot;${__Random(1,28,)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取年龄下疫苗接种情况</stringProp>
            </elementProp>
            <elementProp name="dataGetTrajectory" elementType="Argument">
              <stringProp name="Argument.name">dataGetTrajectory</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;WID&quot;,&quot;gps_time&quot;:&quot;${__time(yyyy-MM-dd,)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取历史轨迹</stringProp>
            </elementProp>
            <elementProp name="dataMoveManager" elementType="Argument">
              <stringProp name="Argument.name">dataMoveManager</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;target_id&quot;:&quot;40&quot;,&quot;friend_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">移交管理员权限</stringProp>
            </elementProp>
            <elementProp name="dataGetAdv" elementType="Argument">
              <stringProp name="Argument.name">dataGetAdv</stringProp>
              <stringProp name="Argument.value">{}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取启动图</stringProp>
            </elementProp>
            <elementProp name="dataGetInfoImg" elementType="Argument">
              <stringProp name="Argument.name">dataGetInfoImg</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.desc">获取咨询广告图</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataIsCerti" elementType="Argument">
              <stringProp name="Argument.name">dataIsCerti</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.desc">是否需要实名认证</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataUploadCertification" elementType="Argument">
              <stringProp name="Argument.name">dataUploadCertification</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;z_image_url&quot;:&quot;&quot;,&quot;f_image_url&quot;:&quot;&quot;,&quot;sc_image_url&quot;:&quot;&quot;}</stringProp>
              <stringProp name="Argument.desc">上传实名认证</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataGetInformationList" elementType="Argument">
              <stringProp name="Argument.name">dataGetInformationList</stringProp>
              <stringProp name="Argument.value">{&quot;type&quot;:&quot;${__Random(1,7,)}&quot;,&quot;pageIndex&quot;:&quot;${pageIndex}&quot;,&quot;pageSize&quot;:&quot;${pageSize}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取咨询列表</stringProp>
            </elementProp>
            <elementProp name="dataGetInfoDetail" elementType="Argument">
              <stringProp name="Argument.name">dataGetInfoDetail</stringProp>
              <stringProp name="Argument.value">{&quot;id&quot;:&quot;AID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取咨询详情</stringProp>
            </elementProp>
            <elementProp name="dataSendSMS" elementType="Argument">
              <stringProp name="Argument.name">dataSendSMS</stringProp>
              <stringProp name="Argument.value">{&quot;key&quot;:&quot;${smskey}&quot;,&quot;phone_num&quot;:&quot;${mobile}&quot;,&quot;create_time&quot;:&quot;${__time(yyyy-MM-dd,)}&quot;,&quot;type&quot;:&quot;${__Random(1,2,)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">发送验证码</stringProp>
            </elementProp>
            <elementProp name="dataFindWatch" elementType="Argument">
              <stringProp name="Argument.name">dataFindWatch</stringProp>
              <stringProp name="Argument.value">{&quot;watch_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">找手表</stringProp>
            </elementProp>
            <elementProp name="dataSendMsg" elementType="Argument">
              <stringProp name="Argument.name">dataSendMsg</stringProp>
              <stringProp name="Argument.value">{&quot;msg_uuid&quot;:&quot;${__UUID}&quot;,&quot;content_type&quot;:&quot;${__Random(1,2,)}&quot;,&quot;content&quot;:&quot;1&quot;,&quot;send_user&quot;:&quot;UID&quot;,&quot;receive_user&quot;:&quot;WID&quot;,&quot;msg_type&quot;:&quot;1&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">发送消息</stringProp>
            </elementProp>
            <elementProp name="dataGetMsg" elementType="Argument">
              <stringProp name="Argument.name">dataGetMsg</stringProp>
              <stringProp name="Argument.value">&quot;data&quot;: {&quot;user_id&quot;:&quot;UID&quot;,&quot;start&quot;:&quot;${__Random(1,5,)}&quot;,&quot;end&quot;:&quot;${__Random(6,20,)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">拉取消息</stringProp>
            </elementProp>
            <elementProp name="dataSetClock" elementType="Argument">
              <stringProp name="Argument.name">dataSetClock</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,${clock}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置闹钟</stringProp>
            </elementProp>
            <elementProp name="dataSetDisturb" elementType="Argument">
              <stringProp name="Argument.name">dataSetDisturb</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,${disturb}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置免打扰</stringProp>
            </elementProp>
            <elementProp name="dataSetSos" elementType="Argument">
              <stringProp name="Argument.name">dataSetSos</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,${sos}}</stringProp>
              <stringProp name="Argument.desc">设置sos</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataSetPhoneBook" elementType="Argument">
              <stringProp name="Argument.name">dataSetPhoneBook</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,${phonebook}}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置电话薄 </stringProp>
            </elementProp>
            <elementProp name="dataSetStep" elementType="Argument">
              <stringProp name="Argument.name">dataSetStep</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,&quot;onOFF&quot;:&quot;${__Random(0,1,)}&quot;}</stringProp>
              <stringProp name="Argument.desc">记步开关 0关 1开</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataSetGPSMode" elementType="Argument">
              <stringProp name="Argument.name">dataSetGPSMode</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;,&quot;gpsMode&quot;:&quot;${__Random(1,3,)}&quot;}</stringProp>
              <stringProp name="Argument.desc">定位模式 1 -正常模式 2 -省电模式 3-高频模式</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="dataPowerOff" elementType="Argument">
              <stringProp name="Argument.name">dataPowerOff</stringProp>
              <stringProp name="Argument.value">{&quot;user_id&quot;:&quot;UID&quot;,&quot;watch_id&quot;:&quot;WID&quot;}</stringProp>
              <stringProp name="Argument.desc">远程关机</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP请求默认值" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="app_v" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${app_v}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">app_v</stringProp>
              </elementProp>
              <elementProp name="platform" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${platform}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">platform</stringProp>
              </elementProp>
              <elementProp name="apiversion" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${apiversion}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">apiversion</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${http_address_test}</stringProp>
          <stringProp name="HTTPSampler.port">${http_port_test}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取启动页图" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getAdv}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetAdv&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="是否注册" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path">${isRegister}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataCheckMobile&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="注册" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${register}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataRegister&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发送验证码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path">${sendSMS}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataSendSMS&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${resetPw}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataResetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="再次重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${resetPw}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataSecondResetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="登录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${login}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataLogin&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">uid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;user_id&quot;:(.+?),</stringProp>
            <stringProp name="RegexExtractor.template">#1#</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname=" 赋值userid" enabled="true">
            <stringProp name="TestPlan.comments">把从正则表达式提取器拿到的userid赋值给全局变量userid</stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">String id=vars.get(&quot;uid_g1&quot;);

log.info(&quot;从后置处理器拿到的uid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;userid&quot;,id);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="是否需要实名认证" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getIsCerti}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataIsCerti&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="上传实名认证" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${uploadCertification}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataUploadCertification&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="解绑手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${unbindWatch}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataUnbindWatch&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="绑定手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${bindWatch}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataBindWatch&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置家庭成员关系" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${editRelation}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataSetRelation&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取用户绑定手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getWatchList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataGetUserWatches&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">wid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;user_id&quot;:(.+?),</stringProp>
            <stringProp name="RegexExtractor.template"></stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">0</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="赋值watchid" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">String id=vars.get(&quot;wid_g1&quot;);

log.info(&quot;从后置处理器拿到的watchid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;watchid&quot;,id);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑用户信息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${editUserInfo}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataEditUserinfo&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑宝贝信息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${editBabyInfo}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataEditBabyInfo&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取手表家庭成员" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getWatchFamliyList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetFamliyList&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取手表电话薄" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getPhoneBook}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetPhoneBook&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取SOS" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getSosList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetSos&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取免打扰" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getWatchDisturbList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataGetDisturb&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取闹钟列表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getWatchClockList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataGetClock&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="增加宝贝成长记录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${addBabyGrowth}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataAddGrowth&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取宝贝成长记录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getBabyGrowth}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;dataAddGrowth&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">gid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;growth_id&quot;:(.+?),</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="赋值给growthid" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">
String Gid=vars.get(&quot;gid_g1&quot;);

log.info(&quot;从后置处理器拿到的Gid: &quot;+Gid);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;growthid&quot;,Gid);

</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑宝贝成长记录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${editBabyGrowth}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataEditGrowth&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;GID&quot;,vars.get(&quot;growthid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="删除宝贝成长记录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${delBabyGrowth}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataDelGrowth&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;GID&quot;,vars.get(&quot;growthid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="增加安全区域" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${addSafeArea}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataAddSafeArea&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取安全区域列表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getWatchSafeAreaList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String id=vars.get(&quot;wid_4_g1&quot;);

String data = vars.get(&quot;dataGetSafeArea&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">sfid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;safe_id&quot;:&quot;(.+?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="赋值给safeid" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">String sfid=vars.get(&quot;sfid_g1&quot;);

log.info(&quot;从后置处理器拿到的sfid: &quot;+sfid);

vars.put(&quot;safeid&quot;,sfid);
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑安全区域" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${editSafeArea}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataEditSafeArea&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;SFID&quot;,vars.get(&quot;safeid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="删除安全区域" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${delSafeArea}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataDelSafeArea&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;SFID&quot;,vars.get(&quot;safeid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取疫苗年龄列表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path">${getAgesList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetAgesList&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取宝贝年龄下疫苗接种情况" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getAgeVaccines}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetAgeVaccine&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));


log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取历史轨迹" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getTrajectoryList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataGetTrajectory&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));


log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="移交管理员权限" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${moveManager}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataMoveManager&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取咨询广告图" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getInfoImg}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataGetInfoImg&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取咨询列表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path">${getInformationList}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetInformationList&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">adid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id&quot;:(.+?),</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">0</stringProp>
          </RegexExtractor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="赋值给adviceid" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">
vars.put(&quot;adviceid&quot;,vars.get(&quot;adid_g1&quot;));

log.info(&quot;赋值后的adviceid:  &quot;+adviceid)</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取咨询内容" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path">${getInfoDetail}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetInfoDetail&quot;);

data=data.replace(&quot;AID&quot;,vars.get(&quot;adviceid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="版本更新" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${versionUpdate}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataVersionUpdate&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="意见反馈" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${addFeedBack}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

//String id=vars.get(&quot;uid_g1&quot;);
//
//log.info(&quot;从后置处理器拿到的uid: &quot;+id);
//
////把登录的userid赋值给  “用户相关变量” userid
//vars.put(&quot;userid&quot;,id);
//
//log.info(&quot;uid: &quot;+vars.get(&quot;userid&quot;));

String data = vars.get(&quot;dataFeedBack&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="找手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${findWatch}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataFindWatch&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发送消息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${sendMsg}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSendMsg&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="拉取消息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${getMsg}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataGetMsg&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置闹钟" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setClock}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSetClock&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置免打扰" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setDisturb}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSetDisturb&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置sos" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setSos}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSetSos&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置电话薄" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setPhoneBook}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSetPhoneBook&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置记步开关" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setStep}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataSetStep&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置定位模式" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${setGPSMode}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataSetGPSMode&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="远程关机" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${powerOff}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }


String data = vars.get(&quot;dataPowerOff&quot;);

data=data.replace(&quot;WID&quot;,vars.get(&quot;watchid&quot;));

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);




    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import net.sf.json.JSONObject;
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String resp = prev.getResponseDataAsString();

log.info(&quot;resp原始： &quot;+ resp);

JSONObject json = JSONObject.fromObject(resp);

String dt = json.get(&quot;data&quot;);

String da = decryptThreeDESECB(dt,key);

log.info(&quot;resp解密后:    &quot;+da);

prev.setResponseData(resp.replace(dt,da));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="保险开关" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="watch_imei" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${watchimei}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">watch_imei</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">cms.bjjajale.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/cms/ucInsuranceControl/isExist.do</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取书籍列表" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/cms/books/book_list.do</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="保险协议获取" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="i" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${__Random(1,6,)}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">i</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${domain}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/cms/insurance/proto.do</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="socket测试" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1451106213000</longProp>
        <longProp name="ThreadGroup.end_time">1451106213000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="全局变量" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="content_txt" elementType="Argument">
              <stringProp name="Argument.name">content_txt</stringProp>
              <stringProp name="Argument.value">hello,world!</stringProp>
              <stringProp name="Argument.desc">发送的文本内容</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="content_voice" elementType="Argument">
              <stringProp name="Argument.name">content_voice</stringProp>
              <stringProp name="Argument.value">Fg6kOmfpVEQOdGCidWn-c9B8lFXs</stringProp>
              <stringProp name="Argument.desc">发送的语音的文件名</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
          <intProp name="groupSize">0</intProp>
          <longProp name="timeoutInMs">0</longProp>
        </SyncTimer>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP请求默认值" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="app_v" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${appversion}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">app_v</stringProp>
              </elementProp>
              <elementProp name="platform" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${platform}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">platform</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${http_address}</stringProp>
          <stringProp name="HTTPSampler.port">${http_port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.response_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
        </ConfigTestElement>
        <hashTree/>
        <ConfigTestElement guiclass="TCPConfigGui" testclass="ConfigTestElement" testname="TCP取样器配置" enabled="false">
          <stringProp name="TCPSampler.server">${address}</stringProp>
          <boolProp name="TCPSampler.reUseConnection">true</boolProp>
          <stringProp name="TCPSampler.port">${port}</stringProp>
          <boolProp name="TCPSampler.nodelay">false</boolProp>
          <stringProp name="TCPSampler.timeout">5000</stringProp>
          <stringProp name="TCPSampler.request"></stringProp>
          <boolProp name="TCPSampler.closeConnection">true</boolProp>
          <stringProp name="TCPSampler.ctimeout">3000</stringProp>
        </ConfigTestElement>
        <hashTree/>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="checkQuery">Select 1</stringProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="dataSource">MSSQL</stringProp>
          <stringProp name="dbUrl">jdbc:sqlserver://${sql_address}:${sql_port};databaseName=${databaseName}</stringProp>
          <stringProp name="driver">com.microsoft.sqlserver.jdbc.SQLServerDriver</stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="password">0.123456!@#QWE</stringProp>
          <stringProp name="poolMax">10</stringProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <stringProp name="username">sa</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="查询账号及手表信息" enabled="false">
          <stringProp name="dataSource">MSSQL</stringProp>
          <stringProp name="query"> SELECT ID  from v_User where UserName=&apos;${mobile}&apos;
union
select ID from Watch where WatchID=&apos;${watchid}&apos;
</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">ID</stringProp>
        </JDBCSampler>
        <hashTree/>
        <JavaSampler guiclass="JavaTestSamplerGui" testclass="JavaSampler" testname="找手表" enabled="false">
          <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="host" elementType="Argument">
                <stringProp name="Argument.name">host</stringProp>
                <stringProp name="Argument.value">${address}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="port" elementType="Argument">
                <stringProp name="Argument.name">port</stringProp>
                <stringProp name="Argument.value">${socket_port}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="RequestTimeout" elementType="Argument">
                <stringProp name="Argument.name">RequestTimeout</stringProp>
                <stringProp name="Argument.value">${timeout}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="ResponseTimeout" elementType="Argument">
                <stringProp name="Argument.name">ResponseTimeout</stringProp>
                <stringProp name="Argument.value">${timeout}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="Data" elementType="Argument">
                <stringProp name="Argument.name">Data</stringProp>
                <stringProp name="Argument.value">${watchid}*31</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="filePath" elementType="Argument">
                <stringProp name="Argument.name">filePath</stringProp>
                <stringProp name="Argument.value">/Users/zhouzhangyin/java/jemter/test.amr</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="isWatchSendVoice" elementType="Argument">
                <stringProp name="Argument.name">isWatchSendVoice</stringProp>
                <stringProp name="Argument.value"></stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="watchId" elementType="Argument">
                <stringProp name="Argument.name">watchId</stringProp>
                <stringProp name="Argument.value"></stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="classname">com.jmeter.TestSocket</stringProp>
        </JavaSampler>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="980906021">${watchid}*31*1</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data_as_document</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
            <stringProp name="Assertion.scope">all</stringProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="模拟app发语音" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10019</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${ID_1}&quot;,&quot;wID&quot;:&quot;${ID_2}&quot;,&quot;messagetype&quot;:&quot;2&quot;,&quot;type&quot;:&quot;0&quot;,&quot;audio_time&quot;:&quot;3&quot;,&quot;content&quot;:&quot;${content_voice}&quot;,&quot;msgID&quot;:&quot;${msgid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">
function newGuid()
{
    var guid = &quot;&quot;;
    for (var i = 1; i &lt;= 32; i++){
      var n = Math.floor(Math.random()*16.0).toString(16);
      guid +=   n;
      if((i==8)||(i==12)||(i==16)||(i==20))
        guid += &quot;-&quot;;
    }
    return guid;    
}

var guid = newGuid();
vars.put(&quot;msgid&quot;,guid);</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">8</intProp>
          </ResponseAssertion>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="正则表达式提取器" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">cd</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;code&quot;:(.+?),</stringProp>
            <stringProp name="RegexExtractor.template">{1}</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <IfController guiclass="IfControllerPanel" testclass="IfController" testname="如果（If）控制器" enabled="false">
          <stringProp name="IfController.condition">${cd_g1}==&quot;200&quot;</stringProp>
          <boolProp name="IfController.evaluateAll">false</boolProp>
        </IfController>
        <hashTree>
          <JavaSampler guiclass="JavaTestSamplerGui" testclass="JavaSampler" testname="app发语音命令" enabled="true">
            <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="host" elementType="Argument">
                  <stringProp name="Argument.name">host</stringProp>
                  <stringProp name="Argument.value">${socket_address}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="port" elementType="Argument">
                  <stringProp name="Argument.name">port</stringProp>
                  <stringProp name="Argument.value">20002</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="RequestTimeout" elementType="Argument">
                  <stringProp name="Argument.name">RequestTimeout</stringProp>
                  <stringProp name="Argument.value">${timeout}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="ResponseTimeout" elementType="Argument">
                  <stringProp name="Argument.name">ResponseTimeout</stringProp>
                  <stringProp name="Argument.value">${timeout}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="Data" elementType="Argument">
                  <stringProp name="Argument.name">Data</stringProp>
                  <stringProp name="Argument.value">${watchid}*29*${content_voice}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="filePath" elementType="Argument">
                  <stringProp name="Argument.name">filePath</stringProp>
                  <stringProp name="Argument.value">/Users/zhouzhangyin/java/jemter/test.amr</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="isWatchSendVoice" elementType="Argument">
                  <stringProp name="Argument.name">isWatchSendVoice</stringProp>
                  <stringProp name="Argument.value"></stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="watchId" elementType="Argument">
                  <stringProp name="Argument.name">watchId</stringProp>
                  <stringProp name="Argument.value">${watchid}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="classname">com.jmeter.TestSocket</stringProp>
          </JavaSampler>
          <hashTree/>
        </hashTree>
        <JavaSampler guiclass="JavaTestSamplerGui" testclass="JavaSampler" testname="模拟手表发语音" enabled="true">
          <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="host" elementType="Argument">
                <stringProp name="Argument.name">host</stringProp>
                <stringProp name="Argument.value">${socket_address}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="port" elementType="Argument">
                <stringProp name="Argument.name">port</stringProp>
                <stringProp name="Argument.value">20001</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="RequestTimeout" elementType="Argument">
                <stringProp name="Argument.name">RequestTimeout</stringProp>
                <stringProp name="Argument.value">20000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="ResponseTimeout" elementType="Argument">
                <stringProp name="Argument.name">ResponseTimeout</stringProp>
                <stringProp name="Argument.value">20000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="Data" elementType="Argument">
                <stringProp name="Argument.name">Data</stringProp>
                <stringProp name="Argument.value">[3G*${watchid}*0002*LK]</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="filePath" elementType="Argument">
                <stringProp name="Argument.name">filePath</stringProp>
                <stringProp name="Argument.value">/Users/zhouzhangyin/java/jmeter/test.amr</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="isWatchSendVoice" elementType="Argument">
                <stringProp name="Argument.name">isWatchSendVoice</stringProp>
                <stringProp name="Argument.value">yes</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="watchId" elementType="Argument">
                <stringProp name="Argument.name">watchId</stringProp>
                <stringProp name="Argument.value">005602001122</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="classname">com.jmeter.TestSocket</stringProp>
        </JavaSampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="C#接口测试" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1449465108000</longProp>
        <longProp name="ThreadGroup.end_time">1449465108000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="请求的data变量" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="dataCheckMobile" elementType="Argument">
              <stringProp name="Argument.name">dataCheckMobile</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">检查手机号是否注册</stringProp>
            </elementProp>
            <elementProp name="dataLogin" elementType="Argument">
              <stringProp name="Argument.name">dataLogin</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${password},)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">登录</stringProp>
            </elementProp>
            <elementProp name="dataBindWatch" elementType="Argument">
              <stringProp name="Argument.name">dataBindWatch</stringProp>
              <stringProp name="Argument.value">{&quot;IMEI&quot;:&quot;${imei}&quot;,&quot;userID&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">绑定手表</stringProp>
            </elementProp>
            <elementProp name="setRelation" elementType="Argument">
              <stringProp name="Argument.name">setRelation</stringProp>
              <stringProp name="Argument.value">{&quot;userID&quot;:&quot;UID&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;relation&quot;:&quot;${relation}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置关系</stringProp>
            </elementProp>
            <elementProp name="editBabyInfo" elementType="Argument">
              <stringProp name="Argument.name">editBabyInfo</stringProp>
              <stringProp name="Argument.value">{&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;portrait&quot;:&quot;${portrait}&quot;,&quot;nickName&quot;:&quot;${nickname}&quot;,&quot;sex&quot;:&quot;${babygender}&quot;,&quot;phone&quot;:&quot;${babyphone}&quot;,&quot;birthday&quot;:&quot;${babybirthday}&quot;}</stringProp>
              <stringProp name="Argument.desc">编辑宝贝信息</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getUserWatches" elementType="Argument">
              <stringProp name="Argument.name">getUserWatches</stringProp>
              <stringProp name="Argument.value">{&quot;userID&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取用户绑定的所有手表</stringProp>
            </elementProp>
            <elementProp name="resetPassword" elementType="Argument">
              <stringProp name="Argument.name">resetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${newPassword},)}&quot;,&quot;num&quot;:&quot;456654&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置密码</stringProp>
            </elementProp>
            <elementProp name="secondResetPassword" elementType="Argument">
              <stringProp name="Argument.name">secondResetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${password},)}&quot;,&quot;num&quot;:&quot;456654&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">重新设置密码</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
          <collectionProp name="HeaderManager.headers"/>
        </HeaderManager>
        <hashTree/>
        <AuthManager guiclass="AuthPanel" testclass="AuthManager" testname="HTTP授权管理器" enabled="true">
          <collectionProp name="AuthManager.auth_list"/>
        </AuthManager>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP请求默认值" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="app_v" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${app_v}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">app_v</stringProp>
              </elementProp>
              <elementProp name="platform" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${platform}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">platform</stringProp>
              </elementProp>
              <elementProp name="apiversion" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${apiversion}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">apiversion</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${http_address}</stringProp>
          <stringProp name="HTTPSampler.port">${http_port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.response_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="手机号是否注册" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10002</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataCheckMobile&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10006</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;resetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="再次重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10006</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;secondResetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="登录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataLogin&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="提取uid" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">uid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;userID&quot;:&quot;(.+?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">{1}</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
            <stringProp name="Scope.variable">userid</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="返回是否是200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="580278297">&quot;code&quot;: &quot;200&quot;</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="绑定手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10003</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String id=vars.get(&quot;uid_g1&quot;);

log.info(&quot;从后置处理器拿到的uid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;userid&quot;,id);
//
//log.info(&quot;uid: &quot;+vars.get(&quot;userid&quot;));





String data = vars.get(&quot;dataBindWatch&quot;);

data=data.replace(&quot;UID&quot;,id);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置家庭成员关系" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10023</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;setRelation&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑宝贝信息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10004</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;editBabyInfo&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取手表信息接口" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10008</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String id=vars.get(&quot;uid_g1&quot;);

log.info(&quot;从后置处理器拿到的uid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;userid&quot;,id);
//
//log.info(&quot;uid: &quot;+vars.get(&quot;userid&quot;));

String data = vars.get(&quot;getUserWatches&quot;);

data=data.replace(&quot;UID&quot;,id);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="提取wID" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">wid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;wID&quot;:&quot;(.+?)&quot;,&quot;watchID&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取家庭成员列表" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10022</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取手表闹钟" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10025</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑手表闹钟" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10024</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,${clock}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="返回是否是200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="580278297">&quot;code&quot;: &quot;200&quot;</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取免打扰" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10026</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置定位模式" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10028</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;gpsMode&quot;:&quot;${gpsmode}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取电话薄" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10039</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置电话簿" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10038</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;phone&quot;:&quot;${mobile}&quot;,&quot;nickName&quot;:&quot;${nickname}&quot;,&quot;number&quot;:&quot;1&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发送消息" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10019</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;wID&quot;:&quot;${wid_g1}&quot;,&quot;type&quot;:&quot;1&quot;,&quot;content&quot;:&quot;你好&quot;,&quot;msgID&quot;:&quot;${msgid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">
function newGuid()
{
    var guid = &quot;&quot;;
    for (var i = 1; i &lt;= 32; i++){
      var n = Math.floor(Math.random()*16.0).toString(16);
      guid +=   n;
      if((i==8)||(i==12)||(i==16)||(i==20))
        guid += &quot;-&quot;;
    }
    return guid;    
}

var guid = newGuid();
vars.put(&quot;msgid&quot;,guid);</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="返回是否是200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取未读消息" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10018</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取历史消息" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10016</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;wID&quot;:&quot;${wid_g1}&quot;,&quot;msgID&quot;:&quot;&quot;,&quot;pageIndex&quot;:&quot;${pageIndex}&quot;,&quot;pageSize&quot;:&quot;${pageSize}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port">8889</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="删除单条聊天记录" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10040</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;msgID&quot;:&quot;${msgid}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="清空聊天记录" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10020</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;wID&quot;:&quot;${wid_g1}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="添加生长记录" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10013</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,${growth}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取宝贝的成长记录" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10012</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;userID&quot;:&quot;${uid_g1}&quot;,&quot;pageIndex&quot;:&quot;${pageIndex}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取常见问题" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10034</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="返回是否是200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="sqlserver功能及性能测试" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">3</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1453370308000</longProp>
        <longProp name="ThreadGroup.end_time">1453370308000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="全局变量" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="databaseName" elementType="Argument">
              <stringProp name="Argument.name">databaseName</stringProp>
              <stringProp name="Argument.value">JaJaLeDB</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
          <stringProp name="filename">/Users/zhouzhangyin/Desktop/imei.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames">imei</stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="checkQuery">Select 1</stringProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="dataSource">MSSQL</stringProp>
          <stringProp name="dbUrl">jdbc:sqlserver://${address}:${port};databaseName=${databaseName}</stringProp>
          <stringProp name="driver">com.microsoft.sqlserver.jdbc.SQLServerDriver</stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="password">0.123456!@#QWE</stringProp>
          <stringProp name="poolMax">10</stringProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <stringProp name="username">sa</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="JDBC Request" enabled="true">
          <stringProp name="dataSource">MSSQL</stringProp>
          <stringProp name="query">select * from v_User where UserName=&apos;${imei}&apos; AS json FROM users</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames"></stringProp>
        </JDBCSampler>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">true</boolProp>
        </DebugSampler>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="察看结果树" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <threadCounts>true</threadCounts>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="mysql功能及性能测试" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1453431044000</longProp>
        <longProp name="ThreadGroup.end_time">1453431044000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="全局变量" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="address" elementType="Argument">
              <stringProp name="Argument.name">address</stringProp>
              <stringProp name="Argument.value">120.24.6.227</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="port" elementType="Argument">
              <stringProp name="Argument.name">port</stringProp>
              <stringProp name="Argument.value">3306</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="databaseName" elementType="Argument">
              <stringProp name="Argument.name">databaseName</stringProp>
              <stringProp name="Argument.value">mg</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
          <stringProp name="dataSource">mysql</stringProp>
          <stringProp name="poolMax">10</stringProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="checkQuery">Select 1</stringProp>
          <stringProp name="dbUrl">jdbc:mysql://${address}:${port}/${databaseName}</stringProp>
          <stringProp name="driver">com.mysql.jdbc.Driver</stringProp>
          <stringProp name="username">cms_online</stringProp>
          <stringProp name="password">123456</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="JDBC Request" enabled="true">
          <stringProp name="dataSource">mysql</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select * from uc_insurance</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="察看结果树" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <threadCounts>true</threadCounts>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="websocket测试" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1454052400000</longProp>
        <longProp name="ThreadGroup.end_time">1454052400000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <JMeter.plugins.functional.samplers.websocket.WebSocketSampler guiclass="JMeter.plugins.functional.samplers.websocket.WebSocketSamplerGui" testclass="JMeter.plugins.functional.samplers.websocket.WebSocketSampler" testname="WebSocket Sampler" enabled="true">
          <stringProp name="serverAddress">112.74.115.143</stringProp>
          <stringProp name="serverPort">20002</stringProp>
          <stringProp name="implementation">RFC6455 (v13)</stringProp>
          <stringProp name="protocol">ws</stringProp>
          <stringProp name="contextPath"></stringProp>
          <stringProp name="contentEncoding">UTF-8</stringProp>
          <stringProp name="requestPayload">${watchid}*31</stringProp>
          <stringProp name="connectionTimeout">5000</stringProp>
          <stringProp name="responseTimeout">20000</stringProp>
          <boolProp name="ignoreSslErrors">false</boolProp>
          <boolProp name="streamingConnection">false</boolProp>
          <stringProp name="connectionId"></stringProp>
          <stringProp name="responsePattern">${watchid}*31*1</stringProp>
          <stringProp name="closeConncectionPattern"></stringProp>
          <stringProp name="proxyAddress"></stringProp>
          <stringProp name="proxyPassword"></stringProp>
          <stringProp name="proxyPort"></stringProp>
          <stringProp name="proxyUsername"></stringProp>
          <stringProp name="messageBacklog"></stringProp>
          <elementProp name="queryStringParameters" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </JMeter.plugins.functional.samplers.websocket.WebSocketSampler>
        <hashTree/>
      </hashTree>
      <kg.apc.jmeter.threads.SteppingThreadGroup guiclass="kg.apc.jmeter.threads.SteppingThreadGroupGui" testclass="kg.apc.jmeter.threads.SteppingThreadGroup" testname="jp@gc - Stepping Thread Group" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <stringProp name="ThreadGroup.num_threads">10</stringProp>
        <stringProp name="Threads initial delay">0</stringProp>
        <stringProp name="Start users count">0</stringProp>
        <stringProp name="Start users count burst">0</stringProp>
        <stringProp name="Start users period">30</stringProp>
        <stringProp name="Stop users count">5</stringProp>
        <stringProp name="Stop users period">1</stringProp>
        <stringProp name="flighttime">60</stringProp>
        <stringProp name="rampUp">5</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">-1</intProp>
        </elementProp>
      </kg.apc.jmeter.threads.SteppingThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="请求的data变量" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="dataCheckMobile" elementType="Argument">
              <stringProp name="Argument.name">dataCheckMobile</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">检查手机号是否注册</stringProp>
            </elementProp>
            <elementProp name="dataLogin" elementType="Argument">
              <stringProp name="Argument.name">dataLogin</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${password},)}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">登录</stringProp>
            </elementProp>
            <elementProp name="dataBindWatch" elementType="Argument">
              <stringProp name="Argument.name">dataBindWatch</stringProp>
              <stringProp name="Argument.value">{&quot;IMEI&quot;:&quot;${imei}&quot;,&quot;userID&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">绑定手表</stringProp>
            </elementProp>
            <elementProp name="setRelation" elementType="Argument">
              <stringProp name="Argument.name">setRelation</stringProp>
              <stringProp name="Argument.value">{&quot;userID&quot;:&quot;UID&quot;,&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;relation&quot;:&quot;${relation}&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置关系</stringProp>
            </elementProp>
            <elementProp name="editBabyInfo" elementType="Argument">
              <stringProp name="Argument.name">editBabyInfo</stringProp>
              <stringProp name="Argument.value">{&quot;watchID&quot;:&quot;${watchid}&quot;,&quot;portrait&quot;:&quot;${portrait}&quot;,&quot;nickName&quot;:&quot;${nickname}&quot;,&quot;sex&quot;:&quot;${babygender}&quot;,&quot;phone&quot;:&quot;${babyphone}&quot;,&quot;birthday&quot;:&quot;${babybirthday}&quot;}</stringProp>
              <stringProp name="Argument.desc">编辑宝贝信息</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="getUserWatches" elementType="Argument">
              <stringProp name="Argument.name">getUserWatches</stringProp>
              <stringProp name="Argument.value">{&quot;userID&quot;:&quot;UID&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">获取用户绑定的所有手表</stringProp>
            </elementProp>
            <elementProp name="resetPassword" elementType="Argument">
              <stringProp name="Argument.name">resetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${newPassword},)}&quot;,&quot;num&quot;:&quot;456654&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">设置密码</stringProp>
            </elementProp>
            <elementProp name="secondResetPassword" elementType="Argument">
              <stringProp name="Argument.name">secondResetPassword</stringProp>
              <stringProp name="Argument.value">{&quot;userName&quot;:&quot;${mobile}&quot;,&quot;passWord&quot;:&quot;${__MD5(${password},)}&quot;,&quot;num&quot;:&quot;456654&quot;}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
              <stringProp name="Argument.desc">重新设置密码</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
          <collectionProp name="HeaderManager.headers"/>
        </HeaderManager>
        <hashTree/>
        <AuthManager guiclass="AuthPanel" testclass="AuthManager" testname="HTTP授权管理器" enabled="true">
          <collectionProp name="AuthManager.auth_list"/>
        </AuthManager>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP请求默认值" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="app_v" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${app_v}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">app_v</stringProp>
              </elementProp>
              <elementProp name="platform" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${platform}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">platform</stringProp>
              </elementProp>
              <elementProp name="apiversion" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${apiversion}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">apiversion</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${http_address}</stringProp>
          <stringProp name="HTTPSampler.port">${http_port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.response_timeout">${timeout}</stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="手机号是否注册" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10002</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataCheckMobile&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10006</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;resetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="再次重置密码" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10006</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;secondResetPassword&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="登录" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;dataLogin&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="提取uid" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">uid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;userID&quot;:&quot;(.+?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">{1}</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
            <stringProp name="Scope.variable">userid</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="返回是否是200" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="580278297">&quot;code&quot;: &quot;200&quot;</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="绑定手表" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10003</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String id=vars.get(&quot;uid_g1&quot;);

log.info(&quot;从后置处理器拿到的uid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;userid&quot;,id);
//
//log.info(&quot;uid: &quot;+vars.get(&quot;userid&quot;));





String data = vars.get(&quot;dataBindWatch&quot;);

data=data.replace(&quot;UID&quot;,id);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="设置家庭成员关系" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10023</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">true</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }



String data = vars.get(&quot;setRelation&quot;);

data=data.replace(&quot;UID&quot;,vars.get(&quot;userid&quot;));

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="编辑宝贝信息" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10004</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String data = vars.get(&quot;editBabyInfo&quot;);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="获取手表信息接口" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">10008</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${data}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path"></stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="data加密" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String id=vars.get(&quot;uid_g1&quot;);

log.info(&quot;从后置处理器拿到的uid: &quot;+id);

//把登录的userid赋值给  “用户相关变量” userid
vars.put(&quot;userid&quot;,id);
//
//log.info(&quot;uid: &quot;+vars.get(&quot;userid&quot;));

String data = vars.get(&quot;getUserWatches&quot;);

data=data.replace(&quot;UID&quot;,id);

log.info(&quot;加密前的data：&quot;+data);

String dataEncry = encryptThreeDESECB(data,key);

log.info(&quot;加密后的data：&quot;+dataEncry);

vars.put(&quot;data&quot;,dataEncry);








    
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="response解密" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;  
   
   String key=&quot;yhgt!d%sd*aw%dsa#mng~dsq&quot;;

   
   
   public  String encryptThreeDESECB(String src,String key)
    {
        try{
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, securekey);
            byte[] b=cipher.doFinal(src.getBytes());

            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(b).replaceAll(&quot;\r&quot;, &quot;&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;);
        }catch (Exception e){
            e.printStackTrace();

            return src;
        }


    }


    //3DESECB解密,key必须是长度大于等于 3*8 = 24 位
    public  String decryptThreeDESECB(String src,String key)
    {

        try{
            //--通过base64,将字符串转成byte数组
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] bytesrc = decoder.decodeBuffer(src);
            //--解密的key
            DESedeKeySpec dks = new DESedeKeySpec(key.getBytes(&quot;UTF-8&quot;));
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DESede&quot;);
            SecretKey securekey = keyFactory.generateSecret(dks);

            //--Chipher对象解密
            Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, securekey);
            byte[] retByte = cipher.doFinal(bytesrc);

            return new String(retByte);
        }catch (Exception e){
            e.printStackTrace();
            return src;
        }

    }

String json = prev.getResponseDataAsString();

log.info(&quot;resp:    &quot;+decryptThreeDESECB(json,key));

prev.setResponseData(decryptThreeDESECB(json,key));



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="提取wID" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">wid</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;wID&quot;:&quot;(.+?)&quot;,&quot;watchID&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number"></stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <kg.apc.jmeter.threads.UltimateThreadGroup guiclass="kg.apc.jmeter.threads.UltimateThreadGroupGui" testclass="kg.apc.jmeter.threads.UltimateThreadGroup" testname="jp@gc - Ultimate Thread Group" enabled="true">
        <collectionProp name="ultimatethreadgroupdata"/>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">-1</intProp>
        </elementProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
      </kg.apc.jmeter.threads.UltimateThreadGroup>
      <hashTree/>
      <kg.apc.jmeter.vizualizers.CorrectedResultCollector guiclass="kg.apc.jmeter.vizualizers.ResponseTimesOverTimeGui" testclass="kg.apc.jmeter.vizualizers.CorrectedResultCollector" testname="jp@gc - Response Times Over Time" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
        <longProp name="interval_grouping">500</longProp>
        <boolProp name="graph_aggregated">false</boolProp>
        <stringProp name="include_sample_labels"></stringProp>
        <stringProp name="exclude_sample_labels"></stringProp>
        <stringProp name="start_offset"></stringProp>
        <stringProp name="end_offset"></stringProp>
        <boolProp name="include_checkbox_state">false</boolProp>
        <boolProp name="exclude_checkbox_state">false</boolProp>
      </kg.apc.jmeter.vizualizers.CorrectedResultCollector>
      <hashTree/>
      <kg.apc.jmeter.vizualizers.CorrectedResultCollector guiclass="kg.apc.jmeter.vizualizers.ResponseTimesDistributionGui" testclass="kg.apc.jmeter.vizualizers.CorrectedResultCollector" testname="jp@gc - Response Times Distribution" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
        <longProp name="interval_grouping">100</longProp>
        <boolProp name="graph_aggregated">false</boolProp>
        <stringProp name="include_sample_labels"></stringProp>
        <stringProp name="exclude_sample_labels"></stringProp>
        <stringProp name="start_offset"></stringProp>
        <stringProp name="end_offset"></stringProp>
        <boolProp name="include_checkbox_state">false</boolProp>
        <boolProp name="exclude_checkbox_state">false</boolProp>
      </kg.apc.jmeter.vizualizers.CorrectedResultCollector>
      <hashTree/>
      <kg.apc.jmeter.vizualizers.CorrectedResultCollector guiclass="kg.apc.jmeter.vizualizers.TimesVsThreadsGui" testclass="kg.apc.jmeter.vizualizers.CorrectedResultCollector" testname="jp@gc - Response Times vs Threads" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
        <longProp name="interval_grouping">500</longProp>
        <boolProp name="graph_aggregated">false</boolProp>
        <stringProp name="include_sample_labels"></stringProp>
        <stringProp name="exclude_sample_labels"></stringProp>
        <stringProp name="start_offset"></stringProp>
        <stringProp name="end_offset"></stringProp>
        <boolProp name="include_checkbox_state">false</boolProp>
        <boolProp name="exclude_checkbox_state">false</boolProp>
      </kg.apc.jmeter.vizualizers.CorrectedResultCollector>
      <hashTree/>
      <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="图形结果" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
